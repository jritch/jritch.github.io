<!DOCTYPE html>
<!-- from: https://bl.ocks.org/wboykinm/dbbe50d1023f90d4e241712395c27fb3 -->
<html lang="en">
<head>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" type="text/css" href="slider.css">

</head>
<body>
<div class="map_container">
<p> One bubble per state.</p>
<p> <b>Color</b>: <span id="color_text">Change in Voter Turnout From 2012 to 2016 (Purple is decrease)</span> </p>
<p> <b>Size</b>: <span id="motion_text">Swing (2016 Margin - 2012 Margin). Rightward motion means more Republican.</span> </p>
<br>
<div class="map">
</div>
<div style="padding-top: 50px">
<p style="text-align: center" id="progress"><b>Progress: 1/4 Questions</b></p>
</div>
</div>
<div class="controls">
    <h2>What patterns do you see in the visualization?</h2>
    <textarea rows=10 columns=200></textarea>
    <br><br>
    <h2>Which dynamic variable creates the most visible patterns in the visualization?</h2>
    <div>
    <select id="select-domininant">
      <option value="1" selected="selected">Color</option>
      <option value="2">Size</option>
    </select>
    <h2>Briefly explain your answer.</h2>
    <textarea rows=10 columns=200></textarea>
    <br></br>
    <input id="submit_answer" type="submit" value="Advance">
</div>
<br>


<script type="text/javascript">


//Width and height of map
var width = 800;
var height = 400;

var global_timer;

function render_map(center,render_mode) {

    var mode = render_mode;
    d3.selectAll("svg").remove();

    // D3 Projection
    var svg = d3.select(".map")
      .append("svg")
      .attr("width", width)
      .attr("height", height);
    //d3.selectAll("circle").remove()

    var projection = d3.geoAlbersUsa()
      .translate(center) // translate to center of screen
      .scale([1600]); // scale things down so see entire US

    // Define path generator
    var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
      .projection(projection); // tell path generator to use albersUsa projection

    //Create SVG element and append map to the SVG
    
    // Load in my states data!
    d3.csv("calculations.csv", function(data) {

      
      function get_ramp(data, varName)  {
        var dataArray = [];

        for (var d = 0; d < data.length; d++) {
            dataArray.push(parseFloat(data[d][varName]))
        }
        var minVal = d3.min(dataArray);
        var maxVal = d3.max(dataArray);
        var absMax= Math.max(Math.abs(minVal),Math.abs(maxVal));
        var ramp = d3.scaleSequential(d3.interpolate(2,25)).domain([-absMax,absMax]);
        return ramp;
      }

      var ramp = get_ramp(data, "turnout_delta");
      var delta_ramp = get_ramp(data, "dem_delta");

      interp_bw = d3.interpolateLab("black","white");

      var static_ramp = d3.scaleSequential(interp_bw).domain([50,80]);
      var static_margin_ramp = d3.scaleSequential(interp_bw).domain([50,80]);

      var g_ramp = d3.scaleSequential(interp_bw).domain([ramp.domain()[0] ,ramp.domain()[1] ]);
      var g_delta_ramp = d3.scaleSequential(interp_bw).domain([delta_ramp.domain()[0]  ,delta_ramp.domain()[1] ]);

      function grayscale_ramp(num) {

          if (num > g_ramp.domain()[1]) {
            return "rgb(255,255,255)";
          }
          else if (num < g_ramp.domain()[0]) {
            return "rgb(0,0,0)";
          }
          else {
            return g_ramp(num);
          }
      }

      function grayscale_delta_ramp(num) {

          if (num > g_delta_ramp.domain()[1]) {
            return "rgb(255,255,255)";
          }
          else if (num < g_delta_ramp.domain()[0]) {
            return "rgb(0,0,0)";
          }
          else {
            return g_delta_ramp(num);
          }
      }

      // Load GeoJSON data and merge with states data
      d3.json("us-states.json", function(json) {

          // load data on the centers
        d3.csv("state_centers.csv", function (centroid_array) {
              

          // Loop through each state data value in the .csv file
          for (var i = 0; i < data.length; i++) {

            // Grab State Name
            var dataState = data[i].state;

            // Grab data value
            var dataValue = data[i].dem_delta;
            var dataFlipped = -1 * data[i].value;
            var dataMargin = data[i]["2016_margin_flip"]
            var dataOldMargin = data[i]["2012_margin"]
            var turnout_delta = data[i]["turnout_delta"]

            // Find the corresponding state inside the GeoJSON
            for (var j = 0; j < json.features.length; j++) {
              var jsonState = json.features[j].properties.name;

              if (dataState == jsonState) {

                // Copy the data value into the JSON
                json.features[j].properties.value = dataValue;
                json.features[j].properties.flipped = dataFlipped;
                json.features[j].properties.margin = dataMargin;
                json.features[j].properties.old_margin = dataOldMargin;
                json.features[j].properties.turnout_delta = turnout_delta;

                json.features[j].properties.votes = 8    // make them all a standard size

                // Stop looking through the JSON
                break;
              }
            }
          }

          // Bind the data to the SVG and create one path per GeoJSON feature
          svg.selectAll("path")
            .data(json.features)
            .enter()
            .append("path")
            .attr("d", path)
            .style("stroke", "#999")
            .style("stroke-width", "1")
            .style("fill", function(d) {
                return "rgb(119,119,119"});

            
            svg.selectAll("circle").data(json.features).enter().append("circle").attr("cx", function (d,i) {
                                                           return projection([centroid_array[i]["Longitude"],centroid_array[i]["Latitude"]])[0]
                                                          })
                                              .attr("cy", function (d,i) {
                                                           return projection([centroid_array[i]["Longitude"],centroid_array[i]["Latitude"]])[1]
                                                          })
            .attr("r", function(d) {
                return Math.sqrt(d.properties.votes) * 2 })
            .attr("fill", function(d) {
                return ramp(d.properties.margin);})
            .style("stroke", "000")
            .style("stroke-width", "1")        

            function play(mode) {
              if (mode == "Mode 1") {
                var circ = d3.selectAll("circle").data(json.features)

                  function do_circle(elapsed) {

                    circ
                    .style("fill", function(d) {

                        col =  $("#grayscale:checked").val() == "on" ? grayscale_delta_ramp : grayscale_delta_ramp;
                      return col(0);})
                    .attr("r", function(d) {
                      return Math.sqrt(ramp(0)) * 3 })
                    .transition()
                    .duration(600)
                    .transition()
                    .duration(2000)
                    .attr("r", function(d) {
                      return Math.sqrt(ramp(d.properties.turnout_delta)) * 3 })
                    .style("fill", function(d) {
                     col =  $("#grayscale:checked").val() == "on" ? grayscale_delta_ramp : grayscale_delta_ramp;
                      return col(d.properties.value);})

                    svg.append("rect").attr("width", width)
                    .attr("height", height).attr("fill","white").transition().duration(700).on("end",function (d) {
                        svg.selectAll("rect").remove()
                    })      

                  }

                  do_circle()
                  global_timer = d3.interval(do_circle, 2700)

              }
              if (mode == "Mode 2") {

                var circ = d3.selectAll("circle").data(json.features)
                

                function do_circle() {
                
                  circ
                  .style("fill", function(d) {

                      col =  $("#grayscale:checked").val() == "on" ? grayscale_ramp : grayscale_ramp;
                      return col(0);})
                  .attr("r", function(d) {
                      return Math.sqrt(delta_ramp(0)) * 3 })
                  .transition()
                  .duration(600)
                  .transition()
                  .duration(2000)
                 
                  .attr("r", function(d) {
                      return Math.sqrt(delta_ramp(d.properties.value)) * 3 })

                  .style("fill", function(d) {
                   col =  $("#grayscale:checked").val() == "on" ? grayscale_ramp : grayscale_ramp;
                   return col(d.properties.turnout_delta)})
                  

                  svg.append("rect").attr("width", width)
                  .attr("height", height).attr("fill","white").transition().duration(700).on("end",function (d) {
                      svg.selectAll("rect").remove()
                  })


                }
                do_circle()
                global_timer = d3.interval(do_circle, 2700)
                
              }
              
            }
            function change_encoding_text(mode){
                if (mode == "Mode 1") {
                  d3.select("#motion_text").html("Change in Voter Turnout From 2012 to 2016 (Becoming smaller is decrease)")
                  d3.select("#color_text").html("Change in Democratic votes from 2012 to 2016. (Darkening is decrease).")
                }
                else {
                  d3.select("#motion_text").html("Change in Democratic votes from 2012 to 2016. (Becoming smaller is decrease).</span> </p>")
                  d3.select("#color_text").html("Change in Voter Turnout From 2012 to 2016. (Darkening is decrease)")
                }
            }

            function reset(mode) {

                if (global_timer != undefined) {
                    global_timer.stop()
                }


                d3.selectAll("circle")
                .data(json.features)
                .attr("transform", "")
            

                svg.selectAll("circle")
                .data(json.features)
                .style("fill", function(d) {
                    return grayscale_ramp(0);
                })
                .attr("r", function(d) {
                    return Math.sqrt(delta_ramp(0)) * 3
                })

              
                change_encoding_text(mode)
            }

          reset(mode)

          d3.select("#play")
               .on("mousedown", function() {play(mode)})
                   .on("touchdown", function() {play(mode)})

            d3.select("#reset")
                .on("mousedown", function() {reset(mode)})
                .on("touchdown", function() {reset(mode)})


           reset(mode)
            play(mode)
        });
      });

    });


}

var answers = []

var questions = [

        [[width * 1/4,height * 1/4], "Mode 1"],
        [[width,height * 3/4], "Mode 2"],
        [[width,height * 1/4], "Mode 1"],
        [[width * 1/4,height], "Mode 2"],

]

question = questions.pop()
render_map(question[0],question[1])

var q = 1;

$("#submit_answer").click( function () {
    
    q++ 

    if (q <= 4) {
        answers.push([$("textarea").val(), $("#select-domininant").val()])
        question = questions.pop()
        $("#progress").html("<b>Progress: "+q+"/4 Questions</b>")
        render_map(question[0],question[1])
    }
    else {
        answers.push([$("textarea").val(), $("#select-domininant").val()])
        $("body").html("<h1>Experiment Complete</h1>")
        
    }
})


</script>
</body>
</html>
